<h3>Problem</h3>

<p>
Your friends made a brave attempt to beat the world record for making the longest sub sandwich ever. They failed or succeeded (it doesn't really matter), and proposed to you to eat as much of the sandwich as you want to.<br/>
The sandwich is composed of N parts. Each part has a taste value for you, which might be positive (meaning you want to eat it) or negative (meaning you would prefer not to). Ideally, you would just eat the tasty parts, but it's rude to break out the middle of the sandwich. So, instead you want to eat some part from the beginning, and some part from the end; and to make the total taste of what you eat as large as possible. The total taste is the sum of tastes of all the parts you have eaten.<br/>
Note: it's OK to eat the whole sandwich, or to eat nothing at all. Output the largest total taste of what you can eat.<br/>
</p>

<h3>Input</h3>
<p>
The input library will be called &quot;sandwich&quot;, see the sample inputs
below for examples in your language. It will define two methods: GetN(), which
will return the number of parts of the sandwich, and GetTaste(i), which will
return the taste of the <i>i</i>th part of the sandwich, for 0&nbsp;&le;&nbsp;i&nbsp;&lt;&nbsp;N.<br/>
A single call to GetTaste(i) will take approximately 0.01 microseconds.<br/>
</p>

<h3>Output</h3>
<p>
Output one number: the maximum possible total taste of the parts you will eat.<br/>
</p>

<h3>Limits</h3>
<p>
Each node will have access to 128MB of RAM, and a time limit of 3 seconds.<br/>
-10<sup>9</sup> &le; GetTaste(i) &le; 10<sup>9</sup> for all i with 0 &le; i &lt; GetN().<br/>
</p>

<h4>Small input</h4>
<p>
Your solution will run on 10 nodes.<br/>
1 &le; GetN() &le; 1000.<br/>
</p>

<h4>Large input</h4>
<p>
Your solution will run on 100 nodes.<br/>
1 &le; GetN() &le; 5 &times; 10<sup>8</sup>.<br/>
</p>
