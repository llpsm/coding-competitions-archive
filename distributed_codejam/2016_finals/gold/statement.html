<h3>Problem</h3>
<p>
A long, long time ago, on an east-west road in southeastern Asia, an ancient
emperor was fleeing from the ruins of his fallen city, carrying a sack full of
his gold. At times, he glanced back over his shoulder and saw pursuers chasing
him, so he threw out a nugget of gold from his sack to the roadside, hoping
to lighten his load and provide a distraction. The story continues, but what
happened later is less important - the important part is that there is gold
lying by the roadside to be picked up!
</p>

<p>
So, you took your trusty metal detector, and went to search for gold on the
road. You have a really fast car, but the detector itself is somewhat slow to
set up and operate, and also a bit inaccurate - it can only tell you in which
direction the nearest nugget of gold is, but not how far. Also, your car cannot
handle off-road driving, so you cannot triangulate; you will just need to
search a bit longer.
</p>

<p>
We will represent the road as a straight line of length <b>L</b>. There
will be <b>N</b> nuggets of gold on the road, at integer positions, no more
than one nugget at each position. You will be able to set up the detector at
integer positions on the road. After setting up, the detector will provide one
of the four possible answers:
<ul>
  <li> The nearest nugget is to the east (towards decreasing position
    numbers),</li>
  <li> The nearest nugget is to the west (towards increasing position
    numbers),</li>
  <li> The nearest nugget to the west and to the east are equally distant,
    or</li>
  <li> There is a nugget at this position.</li>
</ul>
</p>

<h3>Input</h3>
<p>
The input library will be called &quot;gold&quot;, see the sample inputs
below for examples in your language.
It will define three methods:
<ul>
  <li><b>NumberOfNuggets()</b>:
    <ul>
      <li>Takes no argument.</li>
      <li>Returns a 64-bit integer: the number of nuggets on the road.</li>
      <li>Expect each call to take 0.2 microseconds.</li>
    </ul>
  </li>
  <li><b>RoadLength()</b>:
    <ul>
      <li>Takes no argument.</li>
      <li>Returns a 64-bit integer: the number of positions on the road.</li>
      <li>Expect each call to take 0.2 microseconds.</li>
    </ul>
  </li>
  <li><b>Search(i)</b>:
    <ul>
      <li>Takes one 64-bit integer argument in the range 0 &le; i &lt;
        RoadLength().</li>
      <li>Returns a character describing the output of the metal detector:
        <code>&lt;</code> if the nearest nugget is to the east,
        <code>&gt;</code> if it is to the west, <code>=</code> if the nearest
        nuggest to the east and west are equally distant, or <code>X</code> if
        there is a nugget as position <i>i</i>.</li>
      <li>Expect each call to take 0.2 microseconds.</li>
    </ul>
  </li>
</ul>

<h3>Output</h3>
<p>
As printing all the nugget positions would require a lot of printing, you
should output one number - the bitwise XOR of the positions of all the nugget
positions - as a proof you found them all.
</p>

<h3>Limits</h3>
<p>
Number of nodes: 100. <b>(Notice that the number of nodes is the same for both the Small and Large
  datasets.)</b><br/>
Time limit: 15 seconds. <b>(There is a 10 second overhead of initializing the test data that is
  not counted against this limit, so each reported time is 10 seconds more than the time your
  solution executed, up to a maximum of 25.)</b><br/>
Memory limit per node: 512 MB.<br/>
Maximum number of messages a single node can send: 5000.<br/>
Maximum total size of messages a single node can send: 8 MB.<br/>
1 &le; NumberOfNuggets() &le; 10<sup>7</sup>.<br/>
1 &le; RoadLength() &le; 10<sup>11</sup>.<br/>
</p>

<h4>Small input</h4>
<p>
The positions of the nuggets will be generated using a pseudorandom number
generator such that the probability of any subset of positions being chosen is the same.<br/>
</p>

<h4>Large input</h4>
<p>
No additional limits.
</p>
