<h3>Problem</h3>

<p>
As a <i>very important director</i> of a <i>very important company</i>, you have
a lot of files to keep track of. You do this by carefully keeping them sorted.
However, you took a well-deserved vacation last week, and when you came back,
you discovered to your horror that someone has put the files out of place!
</p>

<p>
They are not very much out of place, in fact they're still <i>almost</i> sorted.
More precisely, the file that should be in position <i>i</i> if the files were
sorted is now at most <i>K</i> positions away &mdash; that is, somewhere between
position <i>i &ndash; K</i> and <i>i + K</i>, inclusive.<br/>
However, you can't work like this. So, you ask your assistants to put the files
into their correct places. Each file has an identifier, and files with a larger
identifier should be placed after those with the smaller identifier.
They will not change the relative order of files with the same identifier.<br/>
To verify the files are sorted correctly, you will ask your assistants to
calculate a simple checksum &mdash; for each file multiply that file's
identifier by its position (beginning from 0), and sum this for all files,
modulo 2<sup>20</sup>.
</p>

<p>
Unfortunately, to make use of the checksum, you have to know what it's value
should be. So, write a program that will output the expected checksum
after sorting the files.
</p>

<h3>Input</h3>
<p>
The input library will be called &quot;almost_sorted&quot;; see the sample inputs
below for examples in your language. It will define three methods: NumberOfFiles(), which
will return the number of files, MaxDistance() &mdash; the maximum difference between
the current and desired position of any file, and Identifier(i), which will
return the value of the identifier of the file that's currently standing on
position <i>i</i>, for 0&nbsp;&le;&nbsp;i&nbsp;&lt;&nbsp;NumberOfFiles().<br/>
A single call to Identifier() will take approximately 0.04 microseconds.<br/>
</p>

<h3>Output</h3>
<p>
Output one number &mdash; the value of the checksum for the sorted sequence of
files, modulo 2<sup>20</sup>.
</p>

<h3>Limits</h3>
<p>
Each node will have access to 128MB of RAM, and a time limit of 3 seconds.<br/>
0 &le; Identifier(i) &le; 10<sup>18</sup>, for
0&nbsp;&le;&nbsp;i&nbsp;&lt;&nbsp;NumberOfFiles().
</p>

<h4>Small input</h4>
<p>
Your solution will run on 10 nodes.<br/>
0 &le; MaxDistance() &lt; NumberOfFiles() &le; 1000.<br/>
</p>

<h4>Large input</h4>
<p>
Your solution will run on 100 nodes.<br/>
1 &le; NumberOfFiles() &le; 10<sup>8</sup>.<br/>
0 &le; MaxDistance() &lt; NumberOfFiles().<br/>
0 &le; MaxDistance() &le; 10<sup>6</sup>.<br/>
</p>
