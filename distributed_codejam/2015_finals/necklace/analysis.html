<p>This problem has the simplest sharding model of all the finals problems. We simply assign a piece of the necklace to each node, and calculate a sub-answer for this piece of the necklace in each node, then merge them together.</p>

<p>The sub-problem we solve for each piece of the necklace is: for each position in the message string, calculate the longest substring of the message beginning at this position that is a subsequence of our part of the necklace. This is O(|message|) information we need to ship out of each node to some master. Once we have this information from each node, calculating the final answer is easy - for each possible starting position in the message string, we check how long a substring beginning at this position can is a subsequence of the whole string - first cover as much as possible by the first node, then (starting from where the first node finished) cover as much as possible by the second node, and so on.</p>

<p>How do we solve the sub-problems on a single node? For the small input, we can do a DP, where the state DP[position in necklace][position in message] is "how much of the message have we already covered up to this point". The runtime is O(|message| |necklace| / NumberOfNodes()), with a pretty trivial extension rule. This is enough to solve the small input. </p>

<p>To solve the large input, we can't afford to touch all |necklace| positions for each character in the message. One way to avoid that is to reorganize the necklace - for each charcter, store the ordered list of positions on which the character appears. This takes O(|necklace| / NumberOfNodes()) to build. Then, for each starting position in the message, we can greedily append characters. If the last character we appended was at position, say, X, and the next character to append is some c, then we can binary search for the first occurrence of c after X. Doing all these binary searches will run in O(|message|<sup>2</sup> log |necklace|) time, which will be fast enough.</p>