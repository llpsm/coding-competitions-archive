<p>There are three, very different, potential solutions to this problem, and we will go over all of them.</p>

<p>Let's begin with the naive, single node solution (which doesn't run in time even for the small input). We can construct the Kolakoski sequence as we go, in an array, keeping two pointers into the array - the last constructed element, and the element that was used to describe the group containing the last constructed element. For instance, if we constructed the sequence 1,2,2,1,1,2,1,2,2 so far, then the last constructed element is the 9th (1-indexed), which is a 2, and the element that describes it is the 6th (which is also a 2, and describes the "2,2" run at places 8 and 9). So, we can construct the whole sequence up to GetIndex() this way, and then multiply each element by the appropriate GetMultiplier(). Since the input can go up to 3 billion, and we have just 700MB of memory, we need to store the sequence efficiently - so store one value per bit. Again, as noted, this will not run in time even for the small input. One thing we should remember from this is that to calculate the next elements of the sequence all we need is the elements that describe it, and the information what was the last element before our elements.</p>

<p>One way to speed it up is to use a bit-calculation trick of some sort, to calculate more than one value of the sequence in a single operation. For instance, we can precalculate for each possible sequence of 20 elements and each possible previous element (2<sup>21</sup> choices in all) what will they describe (as a bitmask), and use this to consume 20 elements of the describing sequence at a time. This will speed up the calculation of the sequence roughly 10x, so we will be able to compute the Kolakoski sequence up to 3 billion on one node. We still need to call GetMultiplier 3 billion times, which is too many to do on a single node, but this can be trivially distributed: we have each of the 100 nodes calculate the whole sequence, and then each node actually does the dot-product for only its own shard of the sequence.</p>

<p>A different approach is to try and shard the "expanding". Imagine we have a part of the sequence in hand in our node. This describes a later part of the sequence. This later part describes in turn an even later part, and so on. If we have each node calculate, say, up to 10<sup>7</sup> first elements of the sequence, and then we take the suffix of those 10<sup>7</sup> that describe later elements; and we shard this suffix into 100 parts, we can have each node do its own expanding. There are two pieces of information we need to effectively expand such a part of the sequence - what the first element of the expanded sequence should be (1 or 2), and what the index of the first element in the whole sequence is (so we know what to multiply by).</p>

<p>One way to get this data is to precalculate and hardcode. We can write code on our machine that actually calculates these numbers for each node and for each expansion in a few minutes; and hardcode the values into our solution. Having those, we can easily expand the sequence on each node as needed. Other similar hardcoding-based approaches are also possible, based on the intuition that only <i>log(N)</i> state is needed to expand the sequence up to the <i>N</i>th element.</p>

<p>The last possible approach is the most "distributed" one. Note that we can expand a sequence without knowing the two bits of information - we will just expand it into a sequence of digits, but we will not know which digit is a "1" and which one is a "2". So, we can have all the nodes do a single expansion in parallel. Once they're done, we can do a message-passing phase, where, starting from the first node, each node receives information about what the first element in its sequence and its index are, in constant time calculates the first element and the index of the next node's sequence, and passes that along. After that is done, each node can calculate the dot product and do another expansion (without knowing the first element and offset) in parallel.</p>